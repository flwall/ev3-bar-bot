clear;
close all;
clc;
if exist('robot') ~= true
 robot = legoev3('usb');
end

state=robot_states.INIT;
is_running=1;

%init sensors
disp("Robot connected");
touch = touchSensor(robot);
gyrosensor = gyroSensor(robot);
balanceMotor=motor(robot, 'A');
motorLeft = motor(robot, 'C');
motorRight = motor(robot, 'B');

radius=56/2;
DRIVE_SPEED_LEFT=20;
DRIVE_SPEED_RIGHT=DRIVE_SPEED_LEFT+0;
MAX_SPEED=40;

resetRotationAngle(gyrosensor);
resetRotation(balanceMotor);



while is_running
    switch state
        case robot_states.INIT
            distance=0;
            tic;
            resetRotationAngle(gyrosensor);
            resetRotation(motorLeft);
            resetRotation(motorRight);
            resetRotation(balanceMotor);
            motorLeft.Speed = DRIVE_SPEED_LEFT;
            motorRight.Speed = DRIVE_SPEED_RIGHT;
            balanceMotor.Speed=0;
            writeStatusLight(robot, 'orange', 'solid'); % maybe dont write 

            disp("robot initialized... waiting for start command via touch sensor");
            state=robot_states.WAIT_FOR_START_COMMAND;
        case robot_states.WAIT_FOR_START_COMMAND
            if(readTouch(touch)==1)
                writeStatusLight(robot, 'green', 'solid');
                playTone(robot, 500, 1, 10);

                start(motorLeft);
                start(motorRight);
                start(balanceMotor);
                disp("started motors");
                state=robot_states.DRIVING;
                pause(1);
            end
        case robot_states.DRIVING
            motorRotation = readRotation(motorRight);
            distance=motorRotation * ((2*pi*radius)/360);

            if(readTouch(touch)==1)
                state=robot_states.FINAL;
            else
                if motorLeft.Speed < MAX_SPEED
                    motorLeft.Speed=motorLeft.Speed+0.2;
                end
                if motorRight.Speed < MAX_SPEED
                    motorRight.Speed=motorRight.Speed+0.2;
                end
            end

            angle=double(readRotationAngle(gyrosensor));
    balanceMotorRotation=readRotation(balanceMotor) / double(1.6666666); % uebersetzung von Zahnrad
    
    magicNumber=2.3;
    angleSum= double(-magicNumber) * double(balanceMotorRotation-angle)

    
    if angleSum < 0
        balanceMotor.Speed=angleSum;
        start(balanceMotor);
    elseif angleSum> 0
        balanceMotor.Speed=angleSum;
        start(balanceMotor);
    else
        stop(balanceMotor);
    end

        case robot_states.FINAL
            writeStatusLight(robot, 'red', 'solid');
            beep(robot, 1);
            
            disp("stopping motors");
            stop(balanceMotor);
            stop(motorRight);
            stop(motorLeft);
    
            distance=double(distance)/double(1000);  % mm to metres
            time=toc;
            velocity=distance/time;
            msg=['The robot travelled ', num2str(distance), ' metres in ', num2str(time), ' seconds (=', num2str(velocity), ' m/s)'];
            disp(msg);
            clearLCD(robot);
            writeLCD(robot, msg, 1, 1);
            pause(1);

            % is_running=0;
            state=robot_states.INIT;  % for now, just run the robot forever

        otherwise
            warning("UNRECOGNIZED robot STATE!");
            is_running=0;
    end


end
